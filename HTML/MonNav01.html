<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f2f5;
    }
    header {
      background-color: #4267b2;
      color: white;
      text-align: center;
      padding: 1rem;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .logo {
      width: 100px;
      height: auto;
      margin-right: 20px;
    }
    .header-text {
      text-align: left;
    }
    nav {
      background-color: #365899;
      padding: 10px;
    }
    nav ul {
      list-style-type: none;
      padding: 0;
      margin: 0;
      display: flex;
      justify-content: center;
    }
    nav ul li {
      margin: 0 10px;
    }
    nav ul li a {
      color: white;
      text-decoration: none;
      padding: 5px 10px;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    nav ul li a:hover {
      background-color: #4267b2;
    }
    main {
      background-color: white;
      padding: 20px;
      border-radius: 0 0 8px 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    h1 {
      margin-top: 0;
    }
    h2 {
      color: #4267b2;
    }
    .instructions {
      background-color: #e9ebee;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .instructions ol {
      margin-bottom: 0;
    }
    .code-block {
      background-color: #f1f3f4;
      border-left: 4px solid #4267b2;
      padding: 15px;
      margin-bottom: 20px;
      overflow-x: auto;
    }
    .button {
      display: inline-block;
      background-color: #4267b2;
      color: white;
      padding: 10px 20px;
      text-decoration: none;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    .button:hover {
      background-color: #365899;
    }
    @media (max-width: 600px) {
      header {
        flex-direction: column;
      }
      .logo {
        margin-right: 0;
        margin-bottom: 10px;
      }
      .header-text {
        text-align: center;
      }
    }
    .video-container {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
    }
    .video-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .code-container {
      position: relative;
      margin-bottom: 20px;
    }
    .copy-button {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: #4267b2;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
    }
    .copy-confirmation {
      display: none;
      position: absolute;
      top: 5px;
      right: 80px;
      background-color: #4caf50;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
    }
    .copy-confirmation.show {
      display: block;
    }
    /* Estilo global para la barra de desplazamiento */
    * {
      scrollbar-width: thin;
      scrollbar-color: #6e8efb #e0e0e0;
    }

    /* Webkit browsers like Chrome and Safari */
    *::-webkit-scrollbar {
      width: 22px;
    }

    *::-webkit-scrollbar-track {
      background: #e0e0e0;
    }

    *::-webkit-scrollbar-thumb {
      background-color: #6e8efb;
      border-radius: 20px;
      border: 3px solid #e0e0e0;
    }

    /* Contenedor de ejemplo */
    .scroll-container {
      height: 200px;
      overflow-y: scroll;
      padding: 20px;
      border: 1px solid #ccc;
    }

    .linkedin-logo {
      width: 25%;
    }
  </style>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />
  <meta name="robots" content="index, follow" />
  <meta property="og:title" content="Automatización con PowerShell" />
  <meta
    name="keywords"
    content="PowerShell, scripts, formularios, automatización, administración"
  />
  <meta
    name="description"
    content="Descubre scripts avanzados de PowerShell con formularios para automatizar tareas administrativas. Optimiza la gestión de sistemas, mejora la productividad, aplica la automatizacion y simplifica procesos con nuestras soluciones prácticas y eficientes."
  />
  <title>Scripts de Vladi</title>
  <link rel="shortcut icon" href="./favicon.ico" />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
  />
  <link
    rel="stylesheet"
    href="./assets/vendor/bootstrap-icons/font/bootstrap-icons.css"
  />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
  <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
</head>
<body>
  <header>
    <section id="overview">
      <h1>Calculadora avanzada de PowerShell</h1>
    </section>
    
  </header>
  <nav>
    <ul>
      <li><a href="#overview">Descripción General</a></li>
      <li><a href="#funciones">Funciones</a></li>
      <li><a href="#Uso">Uso</a></li>
      <li><a href="#script-completo">Script Completo</a></li>
    </ul>
  </nav>
  <center>
    <div class="vertical-align">
      <a
        href="https://www.linkedin.com/in/vladimir-campos-830b83328/"
        target="_blank"
      >
        <img
          src="https://campossv.github.io/assets/Linkedin-Logo-e1660320077673.png"
          class="linkedin-logo"
        />
      </a>
    </div>
  </center>
  <main>
    <p>
      El script es una herramienta de monitoreo en tiempo real diseñada para detectar y controlar el uso de navegadores web (Chrome, Firefox, Edge, Internet Explorer) en sistemas Windows. Su principal función es identificar accesos a sitios web sensibles (almacenamiento en la nube, redes sociales, correos electrónicos, etc.) mediante el análisis de títulos de ventanas y URLs, ejecutando acciones automatizadas como:
<ul>
  <li>Captura de pantalla como evidencia.</li>
  <li>Cierre forzado del navegador.</li>
  <li>Registro en logs con detalles del evento.</li>
  <li>Envío de alertas por correo electrónico con pruebas adjuntas.</li>
</ul>
    </p>
    <div class="video-container">
      <iframe width="560" height="315" src="https://www.youtube.com/embed/4CJUXGqyLdE?si=lsIdPVooE6t3cn5s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </div><br>
    
    <section class="code-container">
      <section id="funciones">  
        <h2>Funciones Principales</h2></section>
        <ul>
          <li>Escribir-log</li>
          <li>Send-AlertEmail</li>
          <li>Take-Screenshot</li>
          <li>Get-BrowserUrl</li>
          <li>Test-KeywordsInBrowser</li>
          <li>Monitor-BrowserProcess</li>
          <li>Close-BrowserProcesses</li> 
          <li>Clean-MonitoringState</li>
          <li>Detect-ActiveBrowsers</li>
          <li>Monitor-BrowserEvents</li>
        </p>
        <h2>Diagrama de relación entre funciones</h2>
        <img src="/assets/20250424_f25ff3.svg" class="text-center" alt="Archivos" /><br>
        <br>
        <h3>Función Escribir-log:</h3>
        <section id="codigo-LlaveEncriptacion">
        <div class="code-container">
            <pre><code class="language-powershell" >function Escribir-log {
param (
    [Parameter(Mandatory=$true)]
    [string]$Message,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("INFO", "WARNING", "ERROR", "ALERT")]
    [string]$Level = "INFO",
    
    [Parameter(Mandatory=$false)]
    [ConsoleColor]$ForegroundColor = [ConsoleColor]::White
)

$timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
$logMessage = "[$timestamp] [$Level] $Message"

# Escribir a consola con color
Write-Host $logMessage -ForegroundColor $ForegroundColor

# Escribir a archivo
Add-Content -Path $logFile -Value $logMessage
}
    </code></pre>
    <button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
    <div class="copy-confirmation" aria-live="polite">¡Copiado!</div>
    </div>
    </section>
    <section class="instructions">
      <ul>
        <li><b>Propósito:</b> Registrar eventos en consola y archivo de log con formato estructurado.</li>
        <li><b>Parámetros:</b>
          <ul>
            <li><b>Message:</b> Texto a registrar.</li>
            <li><b>Level:</b> Nivel de severidad (INFO, WARNING, ERROR, ALERT).</li>
            <li><b>ForegroundColor:</b> Color de texto en consola.</li>
          </ul>
        </li>
        <li><b>Flujo:</b>
          <ul>
            <li>Genera un timestamp.</li>
            <li>Escribe en consola (con color) y en el archivo <code>$logFile</code>.</li>
          </ul>
        </li>
      </ul>
    </section>
<br>

<section id="codigo-ProtegerConfig">
    <h3>Funcion Send-AlertEmail:</h3>
    <div class="code-container">
        <pre><code class="language-powershell">function Send-AlertEmail {
param (
    [Parameter(Mandatory=$true)]
    [string]$UserInfo,
    
    [Parameter(Mandatory=$true)]
    [string]$AlertReason,
    
    [Parameter(Mandatory=$true)]
    [string]$Details,
    
    [Parameter(Mandatory=$true)]
    [string]$ScreenshotPath,
    
    [Parameter(Mandatory=$false)]
    [string]$AdditionalInfo = ""
)

try {
    
    # Crear objeto de mensaje de correo directamente

    $mail = New-Object System.Net.Mail.MailMessage
    $mail.From = New-Object System.Net.Mail.MailAddress($emailConfig.From)
    $mail.To.Add($emailConfig.To)
    $mail.Subject = "$($emailConfig.Subject): $AlertReason"
    $mail.IsBodyHtml = $true
    
    
    # Agregar CC si está configurado
    if (-not [string]::IsNullOrWhiteSpace($emailConfig.Cc)) {
        $mail.CC.Add($emailConfig.Cc)
    }
    
    
    # Crear el cuerpo HTML
    $body = @"
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;body style="font-family: Arial, sans-serif;"&gt;
    &lt;img src="cid:$contentId" alt="Logo"&gt;
    &lt;h2 style="color: #cc0000;"&gt;ALERTA DE SEGURIDAD: Sitio Sensible Detectado&lt;/h2&gt;
    &lt;p&gt;&lt;strong&gt;Usuario:&lt;/strong&gt; $UserInfo&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;Motivo de la alerta:&lt;/strong&gt; $AlertReason&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;Detalles:&lt;/strong&gt; $Details&lt;/p&gt;
    &lt;p&gt;&lt;strong&gt;Fecha y hora:&lt;/strong&gt; $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")&lt;/p&gt;
    $AdditionalInfo
    &lt;p&gt;Se adjunta captura de pantalla como evidencia.&lt;/p&gt;
    &lt;p style="color: #666666; font-size: 12px;"&gt;Este es un mensaje automático generado por el sistema de monitoreo de navegadores.&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;
"@

    # Crear vista HTML y agregar el recurso vinculado
    $htmlView = [System.Net.Mail.AlternateView]::CreateAlternateViewFromString($body, $null, "text/html")
    $htmlView.LinkedResources.Add($inlineLogo)
    
    # Agregar la vista HTML a la colección AlternateViews del mensaje
    $mail.AlternateViews.Add($htmlView)
    
    # Agregar adjunto de captura de pantalla
    $attachment = New-Object System.Net.Mail.Attachment($ScreenshotPath)
    $mail.Attachments.Add($attachment)
    
    # Crear cliente SMTP
    $smtp = New-Object System.Net.Mail.SmtpClient($emailConfig.SmtpServer, $emailConfig.SmtpPort)
    $smtp.EnableSsl = $emailConfig.EnableSsl
    
    # Agregar credenciales si es necesario
    if ($emailConfig.UseCredentials) {
        $securePassword = ConvertTo-SecureString $emailConfig.Password -AsPlainText -Force
        $credentials = New-Object System.Management.Automation.PSCredential($emailConfig.Username, $securePassword)
        $smtp.Credentials = $credentials
    }
    
    # Enviar el correo electrónico
    $smtp.Send($mail)
    
    Escribir-log "Correo electrónico de alerta enviado a $($emailConfig.To)" -Level "INFO" -ForegroundColor Green
    return $true
}
catch {
    Escribir-log "Error al enviar correo electrónico: $_" -Level "ERROR" -ForegroundColor Red
    return $false
}
finally {
    
    # Limpiar recursos
    if ($null -ne $attachment) { $attachment.Dispose() }
    if ($null -ne $mail) { $mail.Dispose() }
    if ($null -ne $smtp) { $smtp.Dispose() }
}
}
</code></pre>
<button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
<div id="copyConfirmation2" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
</div>
</section>
<section class="instructions">
  <ul>
    <li><b>Propósito:</b> Enviar correo electrónico con captura de pantalla y detalles de la alerta.</li>
    <li><b>Parámetros:</b>
      <ul>
        <li><b>UserInfo:</b> Usuario que activó la alerta.</li>
        <li><b>AlertReason:</b> Motivo (ej. "Facebook detectado").</li>
        <li><b>Details:</b> URL o título de la ventana.</li>
        <li><b>ScreenshotPath:</b> Ruta de la imagen adjunta.</li>
      </ul>
    </li>
    <li><b>Flujo:</b>
      <ul>
        <li>Crea un cuerpo HTML con logo incrustado (base64).</li>
        <li>Adjunta la captura de pantalla.</li>
        <li>Usa SMTP para enviar el correo (configurable en <code>$emailConfig</code>).</li>
      </ul>
    </li>
  </ul>
</section>
<br>

<section id="codigo-ProbarConexion">
    <h3>Función Take-Screenshot:</h3>
    <div class="code-container">
        <pre><code class="language-powershell">function Take-Screenshot {
  param (
      [string]$UserInfo,
      [string]$Reason,
      [string]$Details,
      [string]$BrowserName = ""
  )
  
  try {
      $screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
      $bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height)
      $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
      
      $graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size)
      
      $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
      $path = "$screenshotDir\Alert_${UserInfo}_$timestamp.png"
      
      $bitmap.Save($path, [System.Drawing.Imaging.ImageFormat]::Png)
      Escribir-log "¡ALERTA! $Reason : '$Details'" -Level "ALERT" -ForegroundColor Red
      Escribir-log "Captura guardada en: $path" -Level "INFO" -ForegroundColor Green

      # Enviar correo electrónico con la evidencia
      $additionalInfo = "<p><strong>Nombre del equipo:</strong> $env:COMPUTERNAME</p>"
      
      # Intentar enviar el correo electrónico pero continuar incluso si falla
      try {
          $emailResult = Send-AlertEmail -UserInfo $UserInfo -AlertReason $Reason -Details $Details -ScreenshotPath $path -AdditionalInfo $additionalInfo
      }
      catch {
          Escribir-log "Error al enviar correo electrónico: $_" -Level "ERROR" -ForegroundColor Red
          $emailResult = $false
      }
      
      # Cerrar procesos del navegador independientemente del éxito del correo electrónico
      if (-not [string]::IsNullOrWhiteSpace($BrowserName)) {
          Escribir-log "Cerrando procesos de navegador independientemente del resultado del correo" -Level "INFO" -ForegroundColor Yellow
          Close-BrowserProcesses -BrowserName $BrowserName
      }
      
      return $path
  } catch {
      Escribir-log "Error al tomar captura: $_" -Level "ERROR" -ForegroundColor Red
      
      # Seguir intentando cerrar procesos del navegador incluso si la captura de pantalla falla
      if (-not [string]::IsNullOrWhiteSpace($BrowserName)) {
          Escribir-log "Intentando cerrar procesos de navegador a pesar del error" -Level "INFO" -ForegroundColor Yellow
          Close-BrowserProcesses -BrowserName $BrowserName
      }
      
      return $null
  } finally {
      if ($graphics) { $graphics.Dispose() }
      if ($bitmap) { $bitmap.Dispose() }
  }
}
</code></pre>
<button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
<div id="copyConfirmation3" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
</div>
</section>
<section class="instructions">
  <ul>
    <li><b>Propósito:</b> Capturar la pantalla y guardarla como PNG.</li>
    <li><b>Parámetros:</b>
      <ul>
        <li><b>UserInfo:</b> Usuario asociado al evento.</li>
        <li><b>Reason:</b> Razón de la captura.</li>
        <li><b>BrowserName:</b> Navegador involucrado (opcional).</li>
      </ul>
    </li>
    <li><b>Flujo:</b>
      <ul>
        <li>Usa <code>System.Drawing</code> para capturar la pantalla primaria.</li>
        <li>Guarda la imagen en <code>$screenshotDir</code> con nombre basado en timestamp.</li>
        <li>Llama a <code>Send-AlertEmail</code> si se requiere.</li>
      </ul>
    </li>
  </ul>
</section>
<br>

<!-- ************************************************************ -->

<section id="codigo-configurar">
    <h3>Funcion Get-BrowserWindowTitles:</h3>
    <div class="code-container">
        <pre><code class="language-powershell">
function Get-BrowserWindowTitles {
  param (
      [string]$BrowserName,
      [int]$ProcessId = 0
  )
  
  $titles = @()
  
  # Obtener todos los procesos del navegador o uno específico
  $processes = if ($ProcessId -gt 0) {
      Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
  } else {
      Get-Process -Name $BrowserName -ErrorAction SilentlyContinue
  }
  
  # Recopilar títulos de ventanas principales
  foreach ($process in $processes) {
      if (-not [string]::IsNullOrWhiteSpace($process.MainWindowTitle)) {
          $titles += [PSCustomObject]@{
              ProcessId = $process.Id
              Title = $process.MainWindowTitle
          }
      }
  }
  
  # Para Chrome, intentar obtener todos los procesos relacionados
  if ($BrowserName -eq "chrome") {
      # Obtener el proceso principal de Chrome (si no se especificó uno)
      if ($ProcessId -eq 0) {
          $mainProcess = Get-Process -Name "chrome" | 
              Where-Object { -not [string]::IsNullOrWhiteSpace($_.MainWindowTitle) } | 
              Select-Object -First 1
              
          if ($mainProcess) {
              $ProcessId = $mainProcess.Id
          }
      }
      
      # Si tenemos un ID de proceso, buscar todos los procesos de Chrome
      if ($ProcessId -gt 0) {
          # Obtener todos los procesos de Chrome
          $allChromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue
          
          # Agregar todos los títulos no vacíos
          foreach ($proc in $allChromeProcesses) {
              if (-not [string]::IsNullOrWhiteSpace($proc.MainWindowTitle)) {
                  $titles += [PSCustomObject]@{
                      ProcessId = $proc.Id
                      Title = $proc.MainWindowTitle
                  }
              }
          }
      }
  }
  
  # Eliminar duplicados
  return $titles | Sort-Object Title -Unique
}
</code></pre>
<button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
<div id="copyConfirmation4" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
</div>
</section>
<section class="instructions">
  <ul>
    <li><b>Propósito:</b> Obtener títulos de ventanas de un navegador específico.</li>
    <li><b>Parámetros:</b>
      <ul>
        <li><b>BrowserName:</b> Nombre del ejecutable (ej. "chrome").</li>
        <li><b>ProcessId:</b> PID del proceso (opcional).</li>
      </ul>
    </li>
    <li><b>Retorna:</b> Array de objetos con ProcessId y Title.</li>
    <li><b>Flujo:</b>
      <ul>
        <li>Usa <code>Get-Process</code> para buscar procesos del navegador.</li>
        <li>Filtra ventanas con título no vacío.</li>
        <li>Para Chrome, busca procesos hijos adicionales.</li>
      </ul>
    </li>
  </ul>
</section>
<br>

 <!-- ************************************************************ -->
 <section id="codigo-completo">
    <h3>función Get-BrowserUrl:</h3>
    <div class="code-container">
        <pre><code class="language-powershell">
function Get-BrowserUrl {
  param (
      [string]$BrowserName,
      [int]$ProcessId
  )
  
  $url = $null
  
  try {
      # Método para Chrome
      if ($BrowserName -eq "chrome") {
          # Intentar obtener la URL usando COM (Shell.Application)
          $shell = New-Object -ComObject Shell.Application
          $windows = $shell.Windows()
          
          for ($i = 0; $i -lt $windows.Count; $i++) {
              $window = $windows.Item($i)
              
              # Verificar si es una ventana de Chrome
              if ($window.FullName -like "*chrome.exe") {
                  $url = $window.LocationURL
                  Escribir-log "URL detectada en Chrome: $url" -Level "INFO" -ForegroundColor Gray
                  break
              }
          }
          
          # Si no se encontró URL, intentar con otro método
          if (-not $url) {
              # Intentar obtener la URL del título (a veces contiene la URL)
              $titles = Get-BrowserWindowTitles -BrowserName $BrowserName -ProcessId $ProcessId
              foreach ($title in $titles) {
                  # Extraer posibles URLs del título
                  if ($title.Title -match '(https?://[^\s]+)') {
                      $url = $matches[1]
                      Escribir-log "URL extraída del título: $url" -Level "INFO" -ForegroundColor Gray
                      break
                  }
              }
          }
      }
      # Método para Firefox
      elseif ($BrowserName -eq "firefox") {
          # Similar al método de Chrome
          $shell = New-Object -ComObject Shell.Application
          $windows = $shell.Windows()
          
          for ($i = 0; $i -lt $windows.Count; $i++) {
              $window = $windows.Item($i)
              if ($window.FullName -like "*firefox.exe") {
                  $url = $window.LocationURL
                  break
              }
          }
      }
      # Método para Internet Explorer
      elseif ($BrowserName -eq "iexplore") {
          $shell = New-Object -ComObject Shell.Application
          $windows = $shell.Windows()
          
          for ($i = 0; $i -lt $windows.Count; $i++) {
              $window = $windows.Item($i)
              if ($window.FullName -like "*iexplore.exe") {
                  $url = $window.LocationURL
                  break
              }
          }
      }
      # Método para Internet Edge
      elseif ($BrowserName -eq "msedge") {
          $shell = New-Object -ComObject Shell.Application
          $windows = $shell.Windows()
          
          for ($i = 0; $i -lt $windows.Count; $i++) {
              $window = $windows.Item($i)
              if ($window.FullName -like "*msedge.exe") {
                  $url = $window.LocationURL
                  break
              }
          }
      }
  }
  catch {
      Escribir-log "Error al obtener URL: $_" -Level "ERROR" -ForegroundColor Red
  }
  
  return $url
}
</code></pre>
<button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
<div id="copyConfirmation5" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
</div>
</section>
<section class="instructions">
  <ul>
    <li><b>Propósito:</b> Obtener la URL activa de un navegador (solo compatible con algunos navegadores).</li>
    <li><b>Parámetros:</b>
      <ul>
        <li><b>BrowserName:</b> Nombre del navegador.</li>
        <li><b>ProcessId:</b> PID del proceso.</li>
      </ul>
    </li>
    <li><b>Retorna:</b> URL como string (o <code>$null</code> si falla).</li>
    <li><b>Flujo:</b>
      <ul>
        <li>Usa el objeto COM <code>Shell.Application</code> para iterar ventanas abiertas.</li>
        <li>Extrae <code>LocationURL</code> si coincide con el navegador.</li>
      </ul>
    </li>
  </ul>
</section>

<br>
<br>
  <!-- ************************************************************ -->
<br>

<section id="script-completo">
<h3>Función Test-KeywordsInBrowser</h3>
</section>
<section id="codigo-ProtegerConfig">
  <div class="code-container">
      <pre><code class="language-powershell">function Test-KeywordsInBrowser {
param (
    [string]$BrowserName,
    [int]$ProcessId = 0
)

$result = @{
    Found = $false
    Keyword = ""
    Description = ""
    Title = ""
    Url = ""
    ProcessId = 0
    FoundInTitle = $false
    FoundInUrl = $false
}

# Obtener todos los títulos de ventanas del navegador
$titles = Get-BrowserWindowTitles -BrowserName $BrowserName -ProcessId $ProcessId

# Mostrar todos los títulos encontrados (para diagnóstico)
Escribir-log "Títulos de ventana encontrados para $BrowserName (PID: $ProcessId):" -Level "INFO" -ForegroundColor Cyan
foreach ($window in $titles) {
    Escribir-log "  - PID: $($window.ProcessId), Título: '$($window.Title)'" -Level "INFO" -ForegroundColor Gray
}

# Verificar si alguno contiene alguna de las palabras clave
foreach ($keyword in $Global:ControlDePalabras.Keys) {
    $matchWindow = $titles | Where-Object { $_.Title -match "(?i)$keyword" } | Select-Object -First 1
    
    if ($matchWindow) {
        $result.Found = $true
        $result.Keyword = $keyword
        $result.Description = $Global:ControlDePalabras[$keyword]
        $result.Title = $matchWindow.Title
        $result.ProcessId = $matchWindow.ProcessId
        $result.FoundInTitle = $true
        break
    }
}

# Intentar obtener la URL actual
$url = Get-BrowserUrl -BrowserName $BrowserName -ProcessId $ProcessId

if ($url) {
    Escribir-log "URL detectada: $url" -Level "INFO" -ForegroundColor Gray
    
    # Verificar si la URL contiene alguna de las palabras clave
    foreach ($keyword in $Global:ControlDePalabras.Keys) {
        if ($url -match "(?i)$keyword") {
            $result.Found = $true
            $result.Keyword = $keyword
            $result.Description = $Global:ControlDePalabras[$keyword]
            $result.Url = $url
            $result.FoundInUrl = $true
            break
        }
    }
}

return $result
}
</code></pre>
<button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
<div id="copyConfirmation2" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
</div>
</section>
<section class="instructions">
  <ul>
    <li><b>Propósito:</b> Buscar palabras clave sensibles en títulos o URLs.</li>
    <li><b>Parámetros:</b>
      <ul>
        <li><b>BrowserName:</b> Nombre del navegador.</li>
        <li><b>ProcessId:</b> PID del proceso (opcional).</li>
      </ul>
    </li>
    <li><b>Retorna:</b> Objeto con:
      <ul>
        <li><b>Found:</b> Booleano indicando si se encontró una palabra clave.</li>
        <li><b>Keyword:</b> Palabra detectada.</li>
        <li><b>Url/Title:</b> Dependiendo de dónde se encontró.</li>
      </ul>
    </li>
    <li><b>Flujo:</b>
      <ul>
        <li>Llama a <code>Get-BrowserWindowTitles</code> y <code>Get-BrowserUrl</code>.</li>
        <li>Compara con las palabras clave en <code>$Global:ControlDePalabras</code>.</li>
      </ul>
    </li>
  </ul>
</section>
<section id="script-completo">
  <h3>Monitor-BrowserProcess</h3>
  </section>
  <section id="codigo-ProtegerConfig">
    <div class="code-container">
        <pre><code class="language-powershell">function Monitor-BrowserProcess {
param (
    [int]$ProcessId,
    [string]$UserInfo,
    [string]$ProcessName
)

# Extraer el nombre base del navegador (sin .exe)
$browserBaseName = $ProcessName -replace '\.exe$', ''

Escribir-log "Iniciando monitoreo del proceso $ProcessName (PID: $ProcessId) iniciado por $UserInfo" -Level "INFO" -ForegroundColor Yellow

# Verificar si el proceso sigue en ejecución antes de iniciar el monitoreo
$processInfo = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
if (-not $processInfo) {
    Escribir-log "El proceso $ProcessName (PID: $ProcessId) ya no está en ejecución. Omitiendo monitoreo." -Level "INFO" -ForegroundColor Yellow
    return
}

# Bucle de monitoreo que continúa hasta que el proceso termina
$capturedKeyword = $false
$lastKeyword = ""
$shouldCloseBrowser = $false

while ($true) {
    # Verificar si el proceso sigue en ejecución
    $processInfo = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
    if (-not $processInfo) {
        Escribir-log "El proceso $ProcessName (PID: $ProcessId) ha terminado. Finalizando monitoreo." -Level "INFO" -ForegroundColor Yellow
        break
    }
    
    # Verificar si alguna ventana del navegador contiene alguna palabra clave en el título o URL
    $result = Test-KeywordsInBrowser -BrowserName $browserBaseName -ProcessId $ProcessId
    
    if ($result.Found) {
        # Solo capturar si es una palabra clave nueva o si ya no estamos capturando
        if (-not $capturedKeyword -or $lastKeyword -ne $result.Keyword) {
            $capturedKeyword = $true
            $lastKeyword = $result.Keyword
            $shouldCloseBrowser = $true
            
            # Determinar la razón de la captura
            $reason = ""
            $details = ""
            
            if ($result.FoundInTitle) {
                $reason = "Sitio sensible detectado en título: $($result.Keyword)"
                $details = $result.Title
            }
            elseif ($result.FoundInUrl) {
                $reason = "URL sensible detectada: $($result.Keyword)"
                $details = $result.Url
            }
            
            Take-Screenshot -UserInfo $UserInfo -Reason $reason -Details $details -BrowserName $ProcessName
            
            Escribir-log "Usuario detectado: $UserInfo" -Level "ALERT" -ForegroundColor Red
            Escribir-log "Sitio sensible: $($result.Keyword) - $($result.Description)" -Level "ALERT" -ForegroundColor Red
            
            if ($result.FoundInTitle) {
                Escribir-log "Título de ventana: $($result.Title)" -Level "ALERT" -ForegroundColor Red
            }
            
            if ($result.FoundInUrl) {
                Escribir-log "URL detectada: $($result.Url)" -Level "ALERT" -ForegroundColor Red
            }
            
            # Si debemos cerrar el navegador pero no se ha cerrado aún, forzar el cierre
            if ($shouldCloseBrowser) {
                # Verificar si el proceso sigue en ejecución
                $processStillRunning = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue
                if ($processStillRunning) {
                    Escribir-log "Forzando cierre del navegador después de detectar sitio sensible" -Level "INFO" -ForegroundColor Yellow
                    Close-BrowserProcesses -BrowserName $ProcessName
                    # Salir del bucle de monitoreo ya que el proceso debería estar cerrado
                    break
                }
            }
        }
    } else {
        # Resetear la bandera si ya no contiene ninguna palabra clave
        $capturedKeyword = $false
        $lastKeyword = ""
    }
    
    # Esperar 20 segundos antes de la siguiente verificación
    Escribir-log "Esperando 20 segundos para la siguiente verificación de '$ProcessName'..." -Level "INFO" -ForegroundColor Gray
    Start-Sleep -Seconds 20
}
}
  </code></pre>
  <button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
  <div id="copyConfirmation2" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
  </div>
  </section>
  <section class="instructions">
    <ul>
      <li><b>Propósito:</b> Cerrar todos los procesos de un navegador.</li>
      <li><b>Parámetros:</b>
        <ul>
          <li><b>BrowserName:</b> Nombre del ejecutable (ej. "chrome.exe").</li>
        </ul>
      </li>
      <li><b>Flujo:</b>
        <ul>
          <li>Usa <code>Get-Process</code> para encontrar todos los procesos del navegador.</li>
          <li>Cierra ventanas con <code>CloseMainWindow()</code>.</li>
          <li>Fuerza cierre con <code>Stop-Process</code> si es necesario.</li>
        </ul>
      </li>
    </ul>
  </section>
  </section>  
  <section id="script-completo">
    <h1>Código Completo</h1>
    </section>
    <section id="codigo-ProtegerConfig">
      <div class="code-container">
          <pre><code class="language-powershell"><#
    .SYNOPSIS
    </code></pre>
    <button class="copy-button" onclick="copyCode(this)" aria-label="Copiar código">Copiar</button>
    <div id="copyConfirmation2" class="copy-confirmation" aria-live="polite">¡Copiado!</div>
    </div>
    </section>
    
  </main>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-powershell.min.js"></script>
    <script src="script.js"></script>
    

</body>
